# -*- coding: utf-8 -*-
"""Copie de TP1_OASIS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PQeTeqJ4MykL6KzGJ4bu-H6Su6rbHbMp
"""

# Cette cellule prepare correctement google colab 
colaboratory=True

if colaboratory:
  !pip install soundfile
  from IPython.display import Audio
  !pip install bokeh
  from bokeh.plotting import figure, output_file, show
  from bokeh.plotting import show as showbokeh
  from bokeh.io import output_notebook
  output_notebook()
!wget https://perso.telecom-paris.fr/ladjal/donnees_tp1_oasis.tgz 
!tar xvf donnees_tp1_oasis.tgz

def valconv(h,u,n):
  a,b = len(h),len(u)
  u,h=u.reshape(-1),h.reshape(-1)
  idx = np.arange(max(0,n+1-b),min(n,a-1)+1)
  return (h[idx]*u[n-idx]).sum()

print(valconv(np.ones(3), np.ones(2),0))
print(valconv(np.ones(3), np.ones(2),1))
print(valconv(np.ones(3), np.ones(2),2))

#%% sections de modules à importer 

import numpy as np
import scipy.signal
import soundfile as sf

import matplotlib.pyplot as plt
import os
import tempfile
import platform

if platform.system()=='Darwin': #MAC 
    import sounddevice as sd
    
def play(y,Fe=44100):
    z=np.real(y)/(abs(np.real(y)).max())
    if colaboratory:
      sh=z.shape
      if len(sh)>1: #la convention stereo de Audio est psychorigide
        if sh[1]==2:
          z=z.T
      return Audio(z,rate=Fe)
    if use_SD: # (sous linux sounddevice a un comportement erratique)
        sd.play(z,Fe)
        return
    fichier=tempfile.mktemp()+'SONTPOASIS.wav'
    sec=len(y)/Fe
    if sec<=20:
        rep=True
    if sec>20:
        print ('Vous allez creer un fichier son de plus de 20 secondes.')
        rep=None
        while rep is None:
            x=input('Voulez-vous continuer? (o/n)')
            if x=='o':
                rep=True
            if x=='n':
                rep=False
            if rep is None:
                print ('Repondre par o ou n, merci. ')
    if rep:
        sf.write(fichier,z,Fe)
        os.system('/usr/bin/play '+fichier+' &')

#%%
print(3+9)

print('suite algebrique (1 est exclu)',np.arange(0, 1, 0.1))
print('matrice de zeros',np.zeros((2, 2)))
print('une colonne',np.zeros((3, 1))) # colonne

print('une ligne',np.zeros((1, 3))) #ligne

#%%
A=np.asarray([[1,2],[ 3 ,4]])
B=np.asarray([[-2,1],[ 1.5 ,-0.5]])
print('A=',A)
print('B=',B)
print('produit matriciel', A@B)
print('produit point a point', A*B)

#%% RESHAPE
A=np.asarray([[1,2],[3,4]])
A.reshape(-1)
u=np.asarray([[1, 2, 2, 1]]) # matrice ligne
v=np.asarray([[1],[2],[3],[4]]) # matrice colonne
print('u*v', u*v) # resultat inatendu (produit tensoriel)
print('u.reshape(-1)*v.reshape(-1)',u.reshape(-1)*v.reshape(-1)) #on est s^ur de la forme c’est le produit point a point

#%%
def valconv(h,u): # cette version ne fonctionne pas telle quelle!
    a=len(h) # pour un tableau numpy len(v)==v.shape[0]
    b=len(u)
    u=u.reshape(-1) #s’assurer que u et v son de la meme forme
    h=h.reshape(-1) #
    out = np.zeros(a+b-1)
    for n in range(len(out)):
      idx=np.arange(max(0,n+1-b),min(n,a-1)+1) # Formule trouvée précédemment
      out[n]=   (h[idx]*u[n-idx]).sum()
    return out

print(valconv(np.ones(3), np.ones(2))) #[1,2,2,1]
print(valconv(np.ones(4), np.ones(4))) #[1,2,3,4,3,2,1]

#%% ATTENTION de bien mettre le bon chemin
repertoire='donnees_tp1_oasis/'
[x,Fe]=sf.read(repertoire+'piano.wav')  #On pourrait aussi écouter [x,Fe] = sf.read(repertoire+'piano.wav)
print(Fe)
#Création de h : 0.01 seconde correspond à 500/44100 soit 500 intervalles de temps (échantillonnage à Fe = 44100 Hz). On écrit ainsi :
h = np.zeros(9001)
h[0],h[9000] = 1, 0.8
newson = valconv(h,x)
#Temps de calcul à tester : newson = scipy.convolve(h,x). Comme on pouvait s'y attendre, il a été optimisé par les types de chez Python et il va donc plus vite que notre valconv.
notes = [1,1.189207115,1.33483985417,1.49830707688,2] #Vecteur ligne des coefficients dans l'ordre pour Do, Mib, Fa, Sol, Do+1. On reconnaît bien un accord parfait... sur un piano désaccordé. (Pas assez précis sur les coefficients)
play(newson,notes[0]*Fe)
#Test quand on réduit la fréquence d'échantillonnage : play(x,Fe/2) fait qu'on a un son une octave plus bas.
#Cela se comprend très bien avec le théorème d'échantillonnage de Nyquist-Shannon, selon lequel une fréquence d'échantillonnage Fe ne permet d'écouter que les sons
#de fréquence inférieure à Fe/2. Donc en faisant play(x,Fe/2), on ne peut écouter que les sons de fréquence inférieure à Fe/4,et donc en réalité on "coupe" 
#l'ensemble des sons de fréquence comprise entre Fe/4 et Fe/2 (notamment la fréquence fondamentale jouée par le piano dans le piano.wav), ce qui fait qu'on entendra 
#la prochaine harmonique en dessous, soit l'octave inférieure, de fréquence (f0)/2.

#J'estime le temps de calcul de mon valconv à quelques secondes (une petite dizaine) contre à peine une pour le scipy.convolve.

#En augmentant le temps de l'écho à 0.2 secondes (càd l'équivalent de 9000 échantillons au lieu des 500 pour le 0.01 secondes), on l'entend bien après le premier, ce
#qui fait qu'il est très audible, on entend CLAIREMENT l'écho. Cela correspond à un temps de trajet de retour plus long, comme si le son nous revenait de la montagne
#ou de la colline face à nous. Pour l'écho de 0.01 seconde, on l'entend à peine, voire pas si on ne fait pas attention. Le son revient direct, comme si on parlait
#face à un mur juste en face de nous. En termes de distances : la vitesse du son étant 340m.s-1, 0.01s correspond à 3.4m de trajet soit un mur placé à 1.7m en face
#de l'émetteur de son (comme prévu), alors que 0.2s correspond à 68m de trajet, soit un mur placé à une trentaine de mètres en face de l'émetteur : une colline 
#ou un mur un peu lointain comme prévu. On peut le vérifier en pratique sans problème devant chez soi !

#%%
fichier='handel.wav'
#fichier='oiseau.wav'
#fichier='marche.wav'
[x,Fe]=sf.read(repertoire+fichier)
play(x,Fe)

#%%
h=np.zeros(3*int(Fe/5))
#h[-1]=0.64
h[int(Fe/2)]=0.8
h[int(Fe/4)]=0.8
#h[-1]=0.8
if len(x.shape)>1: # prendre un seul canal s'il y en a deux
    y=x[:,0].copy()
else:
    y=x.copy()
yecho=scipy.convolve(y,h)
play(np.concatenate((y,yecho),Fe))

#%% une onde
exp=np.exp
i=np.complex(0,1)
pi=np.pi 
n=np.arange(0,100000)
f=0.01
u=exp(2*i*pi*f * n)
play(np.real(u),44100) #ou play(np.real(u),22050)

#Comme je l'ai expliqué plus haut, le théorème d'échantillonnage de Nyquist-Shannon nous dit que l'ensemble des sons que l'on peut décrire avec Fe est l'ensemble des 
#fréquences inférieures à Fe/2. En divisant par 2 cette fréquence, on rejette la limite plus bas et on ne peut écouter que les sons de fréquence plus basse que Fe/4.
#Voilà pourquoi on perçoit une note une octave plus bas ou coupant la fréquence d'échantillonnage par 2. 

#Dans le premier cas, avec 44100 échantillons par seconde, on entend un son joué à 441Hz, alors que pour les 22050 échantillons par seconde, on entend à 220Hz. 
#Pour le calculer, on dit que f/Fe = nu = 0.01, c'est la fréquence réduite entre -0.5 et 0.5.
#Mais ce qu'on entend dépend de la fréquence d'échantillonnage Fe et est obtenu par la formule f = Fe * nu soit ici 0.01 * Fe avec Fe = 44kHz puis 22kHz. 
#                                                                                                                   et on entend donc à 440Hz puis 220Hz (La3 ou A4 puis La2 ou A3)

#Ma console perso -
lfilter = scipy.signal.lfilter
help(lfilter) #ou directement help(scipy.signal.lfilter)

#Le fonctionnement de la fonction est donc le suivant : 
#Supposons que l'on appelle lfilter(L1, L2, L3)
#Dans ce cas on va filtrer L3 par le filtre L1/L2 (L1 est le numérateur et L2 est le dénominateur) et lfilter va renvoyer la liste qu'on stocke plus bas dans sortie
#On rappelle souvent la fonction sur ce qu'on vient de filtrer pour appliquer plusieurs filtres, comme on le voit en-dessous.

#%%

def rejette1(entree,f0,Fs):

#valeur recommandee pour rho: au moins 0.9 et jamais plus de 1
    lfilter=scipy.signal.lfilter
    z0=exp(2*i*pi*f0/Fs); # position sur le cercle unite de la frequence a eliminer
    
    sortie=lfilter([1 ,-z0],1,entree); 
    #Ce premier est l'équivalent de H1(z) = 1 - z0 * z^(-1)

    sortie=lfilter([1, -np.conj(z0)],1,sortie); #Le signal est reel, il faut donc eliminer -f0 aussi!
    #Ce second est l'équivalent de H2(z) = 1 - z0* * z^(-1) (la première étoile est pour le conjugué)
    
    #Le double filtrage donne donc au total H(z) = 1 - 2Re(z0)z^(-1) + |z0|^(2)*z^(-2)

    #Les zéros sont juste à z0 et z0* et y'a pas de pôles (pas de dénominateur comme le montrent les 1 dans les appels à lfilter).
    #Ce rejecteur-ci est plutôt mou, quand les fréquences se rapprochent (sur le cercle unité, visuellement) des zéros, l'amplitude descend doucement
    #et remonte doucement après le zéro. Globalement ça fait des vagues douces du coup ça coupe aussi beaucoup dans des plages assez grandes autour des zéros.

    sortie=np.real(sortie);# En raison d'erreurs d'arrondi il peut subsister une partie imaginaire
    return sortie

def rejette2(entree,f0,Fs,rho):

#valeur recommandee pour rho: au moins 0.9 et jamais plus de 1
    lfilter=scipy.signal.lfilter
    z0=exp(2*i*pi*f0/Fs); # position sur le cercle unite de la frequence a eliminer
    
    sortie=lfilter([1 ,-z0],[1 ,-rho*z0],entree); 
    #Rajout d'un zéro en z0 et d'un pôle en rho*z0. Cela semble dangereux si rho > 1, cela ferait éclater l'entrée, mais cela permet d'être précis dans le rejet. 
    
    sortie=lfilter([1, -np.conj(z0)],[1 ,-rho*np.conj(z0)],sortie); #Le signal est reel, il faut donc eliminer -f0 aussi!
    #Idem mais en z0* c'est-à-dire aux points symétriques par rapport à l'axe réel. 


    #Ce second filtre est beaucoup mieux : grâce aux pôles qui font normalement diverger l'amplitude, quand on se rapproche des zéros, les pôles assurent qu'on ne 
    #descende pas trop. En fait, sur le cercle unité, lorsqu'on se situe loin des zéros/pôles, on peut considérer que la distance entre la fréquence et eux est grande
    #et donc qu'on se situe à la même distance du pôle et du zéro : le filtre ne change donc rien à l'amplitude de cette fréquence -> le filtre vaut 1.
    #Cependant quand on s'en rapproche, ça ne descend pas beaucoup grâce au pôle qui maintient le filtre assez proche de 1. 
    #Mais quand on se rapproche vraiment beaucoup du zéro, comme le pôle est (rho < 1) beaucoup plus loin de la fréquence qu'on est proche du zéro, le zéro l'emporte 
    #et la fréquence est filtrée, le filtre descend à 0 assez précisément. Cela ressemble ainsi beaucoup plus à des créneaux quand l'autre ressemblait à des bosses.
    #La forme est même plutôt du style "pavé - creux abrupt au zéro - pavé - creux abrupt à l'autre zéro - ..."

    #Ce qui fait donc que ce filtre est beaucoup plus efficace car il coupe très près de la fréquence et très peu loin d'elle. Par contre dès qu'on se trompe un peu 
    #dans la fréquence à couper, on ne rejette rien là où l'autre permet une marge d'erreur plus grande puisqu'il coupe "maladroitement".

    sortie=np.real(sortie);# En raison d'erreurs d'arrondi il peut subsister une partie imaginaire
    return sortie

#%% parasite
y=x[:4*Fe]
n=np.arange(len(y)); #le temps discret que dure le signal y
f0=1261;
yb=y+0.1*np.cos(2*pi*f0/Fe*n); #on ajoute une onde parasite
play(yb,Fe)

#La fréquence en Hertz est f0 = 1261 Hz soit nu * Fe avec Fe = 44100 Hz et la fréquence réduite vaut donc f0 / Fe = 0.0286 qui est bien dans [-0.5,0.5]
#Pour les TZ voir les notes dans le truc plus haut.

#%% nettoyage par simple rejection
energ=(y**2).sum()**0.5
ynet=rejette1(yb,f0,Fe)
energn=(ynet**2).sum()**0.5
play(ynet/energn*energ,Fe) #normalisation

#Ce premier filtrage est moyennement satisfaisant : certes, le zéro permet d'atténuer et de couper complètement la fréquence parasite, mais le filtre atténue aussi
#assez fortement l'ensemble des fréquences autour de la fréquence qu'on voulait couper, ce qui fait qu'on n'entend finalement plus grand-chose.

#%% nettoyage en ajoutant un pole dans le filtre
energ=(y**2).sum()**0.5
ynet=rejette2(yb,f0,Fe,0.99) # faire evoluer rho. 0.99 semble très bien, 0.999 commence à faire apparaître un petit bruit, 0.9999 est insupportable. 0.7 atténue de manière un peu désagéable. 
energn=(ynet**2).sum()**0.5
play(ynet/energn*energ,Fe) #normalisation

#Celui-là est quand même beaucoup mieux : la fréquence parasite est coupée et le son du piano est bien clair. 
#Typiquement à 0.99 ça marche nickel, à 0.999 on entend un tout petit bruit gênant au début comme si on tirait une corde de violon,

#%%
def norm2(x):
    return (x**2).sum()**0.5

#%% Ce qui suit est un ensemble de fonctions pour simuler un echo plus realiste
def liste_positions_symetriques(Tx=10,Ty=5,Tz=2.5,xsource=3,ysource=2.5,zsource=1,nrebonds=8):

    accu=[]
    listetrav=[(xsource,ysource,zsource)]
    accu=accu+[(xsource,ysource,zsource)]
    for k in range(nrebonds):

        rebx0= [(-m[0]    ,m[1],m[2]) for m in listetrav] #rebonds sur le mur X=0
        rebxTx=[(2*Tx-m[0],m[1],m[2]) for m in listetrav] #rebonds mur X=Tx
        
        reby0= [(m[0],-m[1]    ,m[2]) for m in listetrav] #rebonds sur le mur Y=0
        rebyTy=[(m[0],2*Ty-m[1],m[2]) for m in listetrav] #rebonds mur Y=Ty

        rebz0= [(m[0],m[1],-m[2]    ) for m in listetrav] #rebonds sur le mur Z=0
        rebzTz=[(m[0],m[1],2*Tz-m[2]) for m in listetrav] #rebonds mur Z=Tz

        listetrav=rebx0+rebxTx+reby0+rebyTy
        accu+=listetrav
    return accu

#%% 
def echosmultiples(Tx=10,Ty=5,Tz=2.5,xsource=3,ysource=2.5,zsource=1,xauditeur=8,yauditeur=1,zauditeur=1,nrebonds=8):
    c=300 # metres/seconde
    listepositions=liste_positions_symetriques(Tx=Tx,Ty=Ty,Tz=Tz,xsource=xsource,ysource=ysource,nrebonds=nrebonds)
    d=[((m[0]-xauditeur)**2+(m[1]-yauditeur)**2+(m[1]-zauditeur)**2)**0.5 for m in listepositions]
    h=np.zeros(int(max(d)/c*Fe+1))

    for k in d:
        posdansh=int(np.floor(k/c*Fe))
        h[posdansh]+=1/k
    return h

#%%
h=echosmultiples(Tx=30,Ty=30,Tz=3,xsource=5,ysource=5,zsource=0.5,xauditeur=20,yauditeur=2,zauditeur=1,nrebonds=8)

#%%
if len(x.shape)>1:
    y=x[:,0].copy()
else:
    y=x.copy()
ny=norm2(y)
yechomult=scipy.convolve(y,h)


play(np.concatenate((y,yechomult)))